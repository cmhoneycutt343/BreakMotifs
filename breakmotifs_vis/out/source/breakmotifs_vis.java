/* autogenerated by Processing revision 1276 on 2022-12-27 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import oscP5.*;
import netP5.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class breakmotifs_vis extends PApplet {

/**
 * oscP5sendreceive by andreas schlegel
 * example shows how to send and receive osc messages.
 * oscP5 website at http://www.sojamo.de/oscP5
 */
 


  
OscP5 oscP5;
NetAddress myRemoteLocation;

boolean debug_verbose = false;
String[] ssybm_arrs = new String[5];
riffdata[] cur_riffs;

String utf_16parsed = "";
int riff_count=0;
boolean riff_busy=true;

 public void setup() {
  /* size commented out by preprocessor */;
  frameRate(25);
  /* start oscP5, listening for incoming messages at port 12000 */
  oscP5 = new OscP5(this,12000);

  cur_riffs = new riffdata[5];
  
  for(int i =0;i<5;i++)
  {
      cur_riffs[i] = new riffdata();
  }
  
  
  /* myRemoteLocation is a NetAddress. a NetAddress takes 2 parameters,
   * an ip address and a port number. myRemoteLocation is used as parameter in
   * oscP5.send() when sending osc packets to another computer, device, 
   * application. usage see below. for testing purposes the listening port
   * and the port of the remote location address are the same, hence you will
   * send messages back to this sketch.
   */
  myRemoteLocation = new NetAddress("127.0.0.1",12000);
  
  String mystring = "READY";

  println(mystring);
  
  ssybm_arrs[0] = "";
  
 
}


 public void draw() {
  background(0);
  
  PFont myfont = createFont("unifont-14.0.01.ttf",50);
  
  textFont(myfont);
  stroke(255);
  fill(255);
  
  //FOR EACH CURRENT RIFF
  for(int i=0;i<(riff_count+1);i++)
  {
    
    //for each char in the riff
    for(int j=0;j<cur_riffs[i].s_count;j++)
    {
       //if it has amplitude data
       if(cur_riffs[i].has_a_data)
       {
          char a_char = cur_riffs[i].a_data.charAt(j);
          
          if(a_char!='_')
          {
            char[] a_chars = Character.toChars(a_char);
            String a_str = new String(a_chars);
            fill(unhex(a_str)*16);
          } else
          {
            fill(255); 
          }
       } 
       else
       {
          fill(255); 
       }
       
       char s_char = cur_riffs[i].s_data.charAt(j);

        //draw if not a space      
       if(s_char!='_')
       {
         //text(cur_riffs[i].s_data.charAt(j),50+j*25,100+50*i);
         if(cur_riffs[i].has_p_data)
         {
             int p_poff = cur_riffs[i].p_data.charAt(j);
             
             fill(255,0,0);
             
             text("555",50+j*25,100+50*i+(10*p_poff));
         }
         
         else{
         text(s_char,50+j*25,100+50*i);
         }
       }
    }
    
  }
}

 public void mousePressed() {
  /* in the following different ways of creating osc messages are shown by example */
  OscMessage myMessage = new OscMessage("/test");
  
  myMessage.add(123); /* add an int to the osc message */

  /* send the message */
  oscP5.send(myMessage, myRemoteLocation); 
}


/* incoming osc message are forwarded to the oscEvent method. */
 public void oscEvent(OscMessage theOscMessage) {
  /* print the address pattern and the typetag of the received OscMessage */
  

  
  if(debug_verbose)
  {
    print("### received an osc message.");
    print(" addrpattern: "+theOscMessage.addrPattern());
    println(" typetag: "+theOscMessage.typetag());
  }
  
  

  if (theOscMessage.addrPattern().equals("/r_index"))
  {
    
    int riff_index = theOscMessage.get(0).intValue();
    
    print("riff_index:");
    println(riff_index);
    riff_count = riff_index;
    

    
    for(int i=0;i<5;i++)
    {
      cur_riffs[riff_index].has_p_data = false;
      cur_riffs[riff_index].has_a_data = false;
    }
  }
  else if(theOscMessage.addrPattern().equals("/ssymb"))
  {
     String string_received = theOscMessage.get(0).stringValue();
    
    if(riff_busy==true)
    {
      riff_busy=false;
       
      //reset riff index
      riff_count=0; 
    }
    
    
    cur_riffs[riff_count].s_data = chuckparse(string_received,false);
    print("[s]-ri:");
    print(riff_count);
    print("-");
    println(cur_riffs[riff_count].s_data);
    
    cur_riffs[riff_count].s_count = PApplet.parseInt(chuckparse(string_received,true));
    print("symbol count:");
    println(cur_riffs[riff_count].s_count);
    
  }
  else if(theOscMessage.addrPattern().equals("/a-ar"))
  {
    String string_received = theOscMessage.get(0).stringValue();
    
    cur_riffs[riff_count].a_data = chuckparse(string_received,false);
    print("[a]-ri:");
    print(riff_count);
    print("-");
    println(cur_riffs[riff_count].a_data);
    
    cur_riffs[riff_count].has_a_data = true;
  }
  
  
  
  else if (theOscMessage.addrPattern().equals("/pkt_end"))
  {
      String string_received = theOscMessage.get(0).stringValue();
    
    riff_busy=true;
    
    print("Riffs in pkt:");
    println(riff_count);
    println(chuckparse(string_received,false));  
  }
  
  
  
  
}
//takes 
 public String chuckparse(String rawbytes, boolean count_only)
{
  //println("bytes received: %d", rawbytes.length());

  //total chars
  int byte_index=0;
  int char_index=0;
  
  String output = new String();

  //repeats for each character in string
  while (byte_index<rawbytes.length())
  {
    byte start_byte = (byte) rawbytes.charAt(byte_index);

    int unicode_bytes = 0;
    int utf_16_Eq = 0;
    String cur_char = new String();

    if (debug_verbose)
    {
      print("Char index[");
      print(char_index);
      print("]-");
      print("0x");
      print(hex(start_byte));
      print(":");
    }

    if ((start_byte&0b10000000)==0)
    {
      if (debug_verbose)
      {
        print("ASCII (1Byte) -> ");


      }
        //print(char(start_byte));
        
        char[] charbuf = new char[1];
        
        charbuf[0]=PApplet.parseChar(start_byte);
        
        cur_char = new String(charbuf);

      unicode_bytes = 1;
    } else
    {
      int length_mask = (start_byte&0b11110000);

      switch(length_mask)
      {
      case 208:
        {
          unicode_bytes = 2;
          break;
        }
      case 192:
        {
          unicode_bytes = 2;
          break;
        }
      case 224:
        {
          unicode_bytes = 3;
          break;
        }
      case 240:
        {
          unicode_bytes = 4;
          break;
        }
      default:
        {
          break;
        }
      }

      if (debug_verbose)
      {
        print("UTF-8 Bytes:");
        print(unicode_bytes);
        print(" -> ");
      }

      //generat unicode char from multi-bytes



      //calculate UTF-16 equivalent
      switch(unicode_bytes)
      {
      case 2:
        {
          int utf_16_byte1 = ((rawbytes.charAt(byte_index)&0x1F)>>2);
          int utf_16_byte2 = (((rawbytes.charAt(byte_index))<<6)&0xFF)|((rawbytes.charAt(byte_index+1)&0x3f));
          utf_16_Eq = (utf_16_byte1<<8)+utf_16_byte2;

          cur_char = print_utf16(utf_16_Eq);
          break;
        }
      case 3:
        {
          int utf_16_byte1 = (((rawbytes.charAt(byte_index))<<4)|(rawbytes.charAt(byte_index+1)&0x3f)>>2)&0xff;
          int utf_16_byte2 = (((rawbytes.charAt(byte_index+1))<<6)&0xFF)|((rawbytes.charAt(byte_index+2)&0x3f));
          utf_16_Eq = (utf_16_byte1<<8)+(utf_16_byte2);

          cur_char = print_utf16(utf_16_Eq);
          break;
        }
      case 4:
        {

          int utf_16_byte1 = (((rawbytes.charAt(byte_index)&0x7)<<2))|((rawbytes.charAt(byte_index+1)&0x3F)>>4);
          int utf_16_byte2 = (((rawbytes.charAt(byte_index+1))<<4)&0xFF)|((rawbytes.charAt(byte_index+2)&0x3f)>>2);
          int utf_16_byte3 = (((rawbytes.charAt(byte_index+2))<<6)&0xFF)|((rawbytes.charAt(byte_index+3)&0x3f));
          utf_16_Eq = (utf_16_byte1<<16)+(utf_16_byte2<<8)+(utf_16_byte3);


          //print(hex(utf_16_byte1));
          //print(hex(utf_16_byte2));
          //print(hex(utf_16_byte3));
          //print(hex(utf_16_Eq));
          cur_char = print_utf16(utf_16_Eq);
          break;
        }
      }
    }
    
    output = output + cur_char;

    char_index++;
    if (debug_verbose)
    {
      println();
    }

    byte_index+=unicode_bytes;
  }
  
  //println();
  if(!count_only)
  {
    return output;
  } 
  else
  {
     //char_index
     return str(char_index);
  }
  
}
 public String print_utf16(int uni_whole)
{
  
   boolean debug_print = false;
  
  //if surrogates needed
  if(uni_whole>65535)
  {
    
    /*
    H = (S - 1000016) / 40016 + D80016
    L = (S - 1000016) % 40016 + DC0016
    */
    
    int h_nib = ((uni_whole - 0x10000) / 0x400) + 0xD800;
    int l_nib = ((uni_whole - 0x10000) % 0x400) + 0xDC00;
    
    String hn = new String(hex(h_nib,4));
    String ln = new String(hex(l_nib,4));
    
    int h = unhex(hn);
    char[] h_char = Character.toChars(h);
    String h_str = new String(h_char);
    
    int l = unhex(ln);
    char[] l_char = Character.toChars(l);
    String l_str = new String(l_char);
    
    String combo = h_str+l_str;
    
    if(debug_print)
    {
    print(combo);
    }
    
    return combo;
  }
  else
  {
    char[] c_char = Character.toChars(uni_whole);
    String c_str = new String(c_char);
    
    if(debug_print)
    {
    print(c_str);
    }
    
    return c_str;
  }
}
public class riffdata{
     String s_data = new String();
     String p_data = new String();
     String a_data = new String();
     
     int s_count;
     
     boolean has_p_data;
     boolean has_a_data;
     
     riffdata()
     {
       s_data = "";
       p_data = "";
       a_data = "";
       s_count=0;
       
       has_p_data=false;
       has_a_data=false;
     }
}


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "breakmotifs_vis" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
